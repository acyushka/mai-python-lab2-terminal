# Консоль Linux: Medium

## Введение
Мини-консоль, поддерживающая выполнение команд Линукса. Выполнены все требования на 100 баллов.
Реализованы команды ls, cd, cat; cp, mv, rm; zip, unzip, tar, untar; grep; history, undo.

Написаны тесты для бизнес-логики. Файлы shell.log и .history не добавлены в гитигнор специально, для презентации.

## Архитектура проекта

```shell
project/
├── .trash       *СКРЫТО*        # Корзина для удаленных файлов
├── src/
│   ├── dependencies/ # Инъекция зависимостей
│   │   └── container.py         # DI Container
│   ├── enums/        # Вспомогательный код
│   │   ├── constants.py         # Константы
│   │   └── file_mode.py         # Типизация режимов чтения у cat
│   ├── services/     # ГЛАВНАЯ БИЗНЕС-ЛОГИКА
│   │   ├── history_service.py   # Сервис для команд history и undo
│   │   └── linux_console.py     # Реализация ls, cd, cat, cp, mv, rm, grep, архивы
│   ├── utils/        # Папка для мини-утилит
│   │   ├── ls.py                # Функции обычного/детальноо вывода ls
│   │   └── validator.py         # Валидатор пути для команд архивации
│   └── main.py       # Точка входа, Typer, интерактивная консоль
├── tests/
│   ├── conftest.py              # Фикстуры для тестов
│   ├── test_archives.py
│   ├── test_cat.py  
│   ├── test_cd.py
│   ├── test_cp.py
│   ├── test_grep.py
│   ├── test_ls.py
│   ├── test_mv.py
│   └── test_rm.py
├── .gitignore
├── .history                     # История введенных пользователем команд
├── .pre-commit-config.yaml      # Линтеры и тп
├── pyproject.toml               # Настройки и описание проекта
├── requirements.txt             # Зависимости
├── shell.log                    # Логи
└── README.md                    # Документация
```

## Запуск консоли

#### Главное требование: Unix-подобная ОС(желательно линукс, за макос не отвечаю)

1) Форкаем репозиторий:

```shell
git clone <ссылка на репозиторий>
```

2) Удаляем shell.log и .history - они нужны были для презентации преподу

3) Создаем и активируем дефолтное виртуальное окружение и импортируем зависимости из requirements.txt

4) Прописываем команду запуска программы. Далее можно начинать работать

```shell
python -m src.main
```

Для выхода из консоли нужно прописать exit

## Как все у меня устроено:

Пользователь вводит команду. Typer на страже, проверяет, что команда знакомая.
Узнает -> выполняется функция в тайпере, которая сначала валидирует аргументы, флаги.
Все хорошо -> инициализируем DI контейнер из контекста тайпера(в контекст засунули созданный в функции main контейнер этот).
В этом чудном контейнере лежит два сервиса с бизнес-логикой: Linux консоль и History сервис.
Далее через контейнер вызываются функции уже в самих сервисах.
И если они там у себя не влетают в исключения, пользователь получает результат.

Подробнее об устройстве сервисов, логировании и занесении в историю, узнаем в следующих разделах.

## Реализация интерактивной консоли

Введу в курс дела: есть Typer, из-за него, чтобы ввести команду линукса всегда приходится писать так: python -m src.main <команда>.
Пытался найти решение проблемы в чистом Typer. В целом терпимо, но это приводит к проблеме выполнения команды cd, при ее вводе перемещение срабатывает, но тайпер в консоли тебя все равно вернет в исходное место.
Поэтому я искал способ запустить интерактивную консоль в других библиотеках: нашел сначала какой-то typer-shell, который работать на захотел.

И вот спустя несколько дней я нашел на стэк оверфлоу способ через тайпер подрубить click-shell - более популярный модуль для интерактивной консоли.
И о чудо, это хотя бы заработало. Если ничего не вводить кроме python -m src.main, то запустится функция base, в которой я на всякий случай прикрутил всё из функции main.
И в которой потом выполнится команда создания интерактивного шелла.

Были там конечно несколько проблем и мне их удалось решить(и благодаря этому я сократил код всех остальных функций тайпера):

1) Логирование самих команд, до этого оно было в каждой функции в тайпере. Оно не происходило, потому что эта консоль логировала только путь запуска консоли.
Но я узнал о функциях precmd и postcmd у click-shell(это типа функции-хуки, которые срабатывают до и после ввода в консоль). 
Так вот и создал внутри base функцию-мидлвар для precmd, которая уже умеет логировать введенную в консоль команду.
2) Запись в историю: история аналогично с предыдущей, т.е. помимо лоигрования можно еще и в precmd добавить команду в историю и это тоже работает прекрасно.
3) Ну и вишенка на тортике: динамический путь в интерактивной консоли(т.е. меняющийся при cd) получилось реализовать благодаря подкрутке к хуку postcmd обновления промпта, который выводился в каждой появлявшейся строке консоли.
Брал этот путь из переменной current_path класса сервиса Linux.

Очень понравилась реализация такой консольки.

## Описание каждой команды по-отдельности

### Предисловие

У каждой команды обрабатываются введенные пути, и они преобразуются так, как требуется программе, поэтому обсуждать это не буду, просто каждая программа валидирует каждый введенный путь.


### ls

Поддерживаемые флаги: -a (вывод скрытых файлов), -l (детальный вывод)

Сначала перебираем файлы и каталоги у заданного пути через pathlib.iterdir(), потом удаляем скрытые, если не указан -а.

Дальше проверяем флаг -l и в зависимости от этого обращаемся к нужной функции вывода результата в файле src/utils/ls.py

Примечание: при наличии флага -l выводятся только те, столбцы, что указаны в лабораторной (т.е. без имени пользователя)

### cd

Флагов нет. Программа пытается образовать абсолютный путь из заданного
Потом через os.chdir() меняем директорию, и обновляем переменную текущего пути в классе

### cat

Есть флаг -b для чтения как слайс байтов.

Реализация почти полностью скопирована с шаблона Самира, только под себя поимку исключений сделал.
Для получения результата используется pathlib.read_text()/read_bytes в зависимости от флага.

### cp

Есть флаг -r для рекурсивного копирования каталогов.

Для копирования файлов используется shutil.copy2(). Копирование каталогов при наличии -r осуществляется через shutil.copytree().

### mv

Флагов нет. Перемещение реализуется очень лаконично: через shutil.move().

### rm

Флаг, конечно, -r для рекурсивного удаления каталогов в наличии.

Если задан файл: os.remove(). Если каталог и указан флаг: shutil.rmtree() и сначала спрашиваем пользователя, согласен ли он на удаление.

### zip, tar, unzip, untar

Расскажу про это про все сразу:

Флагов ни для чего нет. В классе сервиса реализованы функции archive и unpack_archive для архивации и обратного действия, соответственно.
Эти функции принимают параметр формата: то есть из функций тайпера вызываются данные функции в сервисе с указанным форматом: zip или tar.
Функция archive работает через shutil.make_archive(), unpack_archive через одноименный shutil.unpack_archive().

### grep

Флаги -r (рекурсивный поиск по каталогам) и -i (игнорирование регистра)

В начале пытаемся скомпилировать регулярку, при этом смотря на наличие флага -i.
Если задан файл, то просто проходимся по каждой строке и ищем там по регулярке.
Если задан каталог и -r, то благодаря прекрасной функции os.walk рекурсивно по каталогу проходимся.
А там уже по каждому файлу история аналогичная, но при этом путь к файлу обозначаем не абсолютный, а ближайший к заданному каталогу.

### history и undo

Undo реализуется через стек.

Как таковых функций для команд в сервисе нет, есть отдельные функции добавления и удаления в сервисе Истории.
В целом все там тривиально

Единственное, что скажу, это что в функции undo у тайпера я переиспользую готовые функции: для rm - mv в корзину, для cp - rm, для mv - тоже mv c обратными путями 

## Логирование

Используется библиотека loguru. Все логи отправляются в shell.log. Как сказано выше, сама команда логируется при precmd каждого ввода пользователя.
Далее рассмотрим функции самих команд тайпера. Во всех этих функциях обращение к сервису обернуто в блоки try-except.
После получения успешного результата после вызова сервиса логируется SUCCESS.
При поимки исключения логируется ошибка и ее содержимое.

## Допущения

1) Выполнение команды undo возможно только в одном сеансе интерактивной консоли, то есть при перезапуски консоли выполнить ее нельзя. Хоть она и позволяет даже стрелочками листать последние вводы человека, найти способ решения проблемы я не смог. У меня ведь все-таки и так клик-шелл в тайпере, одна cli аппа в другой.

## Юнит тесты

Используется библиотека pytest.
Написано 69 тестов для всех функций из сервиса Linux Console.
Метод тестирования через создание в фикстурах фейковой файловой системы.

Запуск:

```shell
python -m pytest -vv
```

undo не тестируется, потому что оно переиспользует функции mv и rm, которые уже протестированы максимально, как мне удалось.
history не тестируется, потому что это, кажется, не так легко через фейковую систему, при том, что сервис довольно тривиальный и его правильная реализация видна в .history, а все варианты ввода я и сам проверил, и все работает как надо.
